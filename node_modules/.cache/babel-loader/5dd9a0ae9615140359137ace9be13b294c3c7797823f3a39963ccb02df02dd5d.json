{"ast":null,"code":"// drag\n(function (window, factory) {\n  // universal module definition\n  if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('./core'), require('unidragger'), require('fizzy-ui-utils'));\n  } else {\n    // browser global\n    window.Flickity = factory(window, window.Flickity, window.Unidragger, window.fizzyUIUtils);\n  }\n})(typeof window != 'undefined' ? window : this, function factory(window, Flickity, Unidragger, utils) {\n  // ----- defaults ----- //\n\n  Object.assign(Flickity.defaults, {\n    draggable: '>1',\n    dragThreshold: 3\n  });\n\n  // -------------------------- drag prototype -------------------------- //\n\n  let proto = Flickity.prototype;\n  Object.assign(proto, Unidragger.prototype); // inherit Unidragger\n  proto.touchActionValue = '';\n\n  // --------------------------  -------------------------- //\n\n  Flickity.create.drag = function () {\n    this.on('activate', this.onActivateDrag);\n    this.on('uiChange', this._uiChangeDrag);\n    this.on('deactivate', this.onDeactivateDrag);\n    this.on('cellChange', this.updateDraggable);\n    this.on('pointerDown', this.handlePointerDown);\n    this.on('pointerUp', this.handlePointerUp);\n    this.on('pointerDown', this.handlePointerDone);\n    this.on('dragStart', this.handleDragStart);\n    this.on('dragMove', this.handleDragMove);\n    this.on('dragEnd', this.handleDragEnd);\n    this.on('staticClick', this.handleStaticClick);\n    // TODO updateDraggable on resize? if groupCells & slides change\n  };\n\n  proto.onActivateDrag = function () {\n    this.handles = [this.viewport];\n    this.bindHandles();\n    this.updateDraggable();\n  };\n  proto.onDeactivateDrag = function () {\n    this.unbindHandles();\n    this.element.classList.remove('is-draggable');\n  };\n  proto.updateDraggable = function () {\n    // disable dragging if less than 2 slides. #278\n    if (this.options.draggable === '>1') {\n      this.isDraggable = this.slides.length > 1;\n    } else {\n      this.isDraggable = this.options.draggable;\n    }\n    this.element.classList.toggle('is-draggable', this.isDraggable);\n  };\n  proto._uiChangeDrag = function () {\n    delete this.isFreeScrolling;\n  };\n\n  // -------------------------- pointer events -------------------------- //\n\n  proto.handlePointerDown = function (event) {\n    if (!this.isDraggable) {\n      // proceed for staticClick\n      this.bindActivePointerEvents(event);\n      return;\n    }\n    let isTouchStart = event.type === 'touchstart';\n    let isTouchPointer = event.pointerType === 'touch';\n    let isFocusNode = event.target.matches('input, textarea, select');\n    if (!isTouchStart && !isTouchPointer && !isFocusNode) event.preventDefault();\n    if (!isFocusNode) this.focus();\n    // blur\n    if (document.activeElement !== this.element) document.activeElement.blur();\n    // stop if it was moving\n    this.dragX = this.x;\n    this.viewport.classList.add('is-pointer-down');\n    // track scrolling\n    this.pointerDownScroll = getScrollPosition();\n    window.addEventListener('scroll', this);\n    this.bindActivePointerEvents(event);\n  };\n\n  // ----- move ----- //\n\n  proto.hasDragStarted = function (moveVector) {\n    return Math.abs(moveVector.x) > this.options.dragThreshold;\n  };\n\n  // ----- up ----- //\n\n  proto.handlePointerUp = function () {\n    delete this.isTouchScrolling;\n    this.viewport.classList.remove('is-pointer-down');\n  };\n  proto.handlePointerDone = function () {\n    window.removeEventListener('scroll', this);\n    delete this.pointerDownScroll;\n  };\n\n  // -------------------------- dragging -------------------------- //\n\n  proto.handleDragStart = function () {\n    if (!this.isDraggable) return;\n    this.dragStartPosition = this.x;\n    this.startAnimation();\n    window.removeEventListener('scroll', this);\n  };\n  proto.handleDragMove = function (event, pointer, moveVector) {\n    if (!this.isDraggable) return;\n    event.preventDefault();\n    this.previousDragX = this.dragX;\n    // reverse if right-to-left\n    let direction = this.options.rightToLeft ? -1 : 1;\n    // wrap around move. #589\n    if (this.isWrapping) moveVector.x %= this.slideableWidth;\n    let dragX = this.dragStartPosition + moveVector.x * direction;\n    if (!this.isWrapping) {\n      // slow drag\n      let originBound = Math.max(-this.slides[0].target, this.dragStartPosition);\n      dragX = dragX > originBound ? (dragX + originBound) * 0.5 : dragX;\n      let endBound = Math.min(-this.getLastSlide().target, this.dragStartPosition);\n      dragX = dragX < endBound ? (dragX + endBound) * 0.5 : dragX;\n    }\n    this.dragX = dragX;\n    this.dragMoveTime = new Date();\n  };\n  proto.handleDragEnd = function () {\n    if (!this.isDraggable) return;\n    let {\n      freeScroll\n    } = this.options;\n    if (freeScroll) this.isFreeScrolling = true;\n    // set selectedIndex based on where flick will end up\n    let index = this.dragEndRestingSelect();\n    if (freeScroll && !this.isWrapping) {\n      // if free-scroll & not wrap around\n      // do not free-scroll if going outside of bounding slides\n      // so bounding slides can attract slider, and keep it in bounds\n      let restingX = this.getRestingPosition();\n      this.isFreeScrolling = -restingX > this.slides[0].target && -restingX < this.getLastSlide().target;\n    } else if (!freeScroll && index === this.selectedIndex) {\n      // boost selection if selected index has not changed\n      index += this.dragEndBoostSelect();\n    }\n    delete this.previousDragX;\n    // apply selection\n    // HACK, set flag so dragging stays in correct direction\n    this.isDragSelect = this.isWrapping;\n    this.select(index);\n    delete this.isDragSelect;\n  };\n  proto.dragEndRestingSelect = function () {\n    let restingX = this.getRestingPosition();\n    // how far away from selected slide\n    let distance = Math.abs(this.getSlideDistance(-restingX, this.selectedIndex));\n    // get closet resting going up and going down\n    let positiveResting = this._getClosestResting(restingX, distance, 1);\n    let negativeResting = this._getClosestResting(restingX, distance, -1);\n    // use closer resting for wrap-around\n    return positiveResting.distance < negativeResting.distance ? positiveResting.index : negativeResting.index;\n  };\n\n  /**\n   * given resting X and distance to selected cell\n   * get the distance and index of the closest cell\n   * @param {Number} restingX - estimated post-flick resting position\n   * @param {Number} distance - distance to selected cell\n   * @param {Integer} increment - +1 or -1, going up or down\n   * @returns {Object} - { distance: {Number}, index: {Integer} }\n   */\n  proto._getClosestResting = function (restingX, distance, increment) {\n    let index = this.selectedIndex;\n    let minDistance = Infinity;\n    let condition = this.options.contain && !this.isWrapping ?\n    // if containing, keep going if distance is equal to minDistance\n    (dist, minDist) => dist <= minDist : (dist, minDist) => dist < minDist;\n    while (condition(distance, minDistance)) {\n      // measure distance to next cell\n      index += increment;\n      minDistance = distance;\n      distance = this.getSlideDistance(-restingX, index);\n      if (distance === null) break;\n      distance = Math.abs(distance);\n    }\n    return {\n      distance: minDistance,\n      // selected was previous index\n      index: index - increment\n    };\n  };\n\n  /**\n   * measure distance between x and a slide target\n   * @param {Number} x - horizontal position\n   * @param {Integer} index - slide index\n   * @returns {Number} - slide distance\n   */\n  proto.getSlideDistance = function (x, index) {\n    let len = this.slides.length;\n    // wrap around if at least 2 slides\n    let isWrapAround = this.options.wrapAround && len > 1;\n    let slideIndex = isWrapAround ? utils.modulo(index, len) : index;\n    let slide = this.slides[slideIndex];\n    if (!slide) return null;\n\n    // add distance for wrap-around slides\n    let wrap = isWrapAround ? this.slideableWidth * Math.floor(index / len) : 0;\n    return x - (slide.target + wrap);\n  };\n  proto.dragEndBoostSelect = function () {\n    // do not boost if no previousDragX or dragMoveTime\n    if (this.previousDragX === undefined || !this.dragMoveTime ||\n    // or if drag was held for 100 ms\n    new Date() - this.dragMoveTime > 100) {\n      return 0;\n    }\n    let distance = this.getSlideDistance(-this.dragX, this.selectedIndex);\n    let delta = this.previousDragX - this.dragX;\n    if (distance > 0 && delta > 0) {\n      // boost to next if moving towards the right, and positive velocity\n      return 1;\n    } else if (distance < 0 && delta < 0) {\n      // boost to previous if moving towards the left, and negative velocity\n      return -1;\n    }\n    return 0;\n  };\n\n  // ----- scroll ----- //\n\n  proto.onscroll = function () {\n    let scroll = getScrollPosition();\n    let scrollMoveX = this.pointerDownScroll.x - scroll.x;\n    let scrollMoveY = this.pointerDownScroll.y - scroll.y;\n    // cancel click/tap if scroll is too much\n    if (Math.abs(scrollMoveX) > 3 || Math.abs(scrollMoveY) > 3) {\n      this.pointerDone();\n    }\n  };\n\n  // ----- utils ----- //\n\n  function getScrollPosition() {\n    return {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n\n  // -----  ----- //\n\n  return Flickity;\n});","map":{"version":3,"names":["window","factory","module","exports","require","Flickity","Unidragger","fizzyUIUtils","utils","Object","assign","defaults","draggable","dragThreshold","proto","prototype","touchActionValue","create","drag","on","onActivateDrag","_uiChangeDrag","onDeactivateDrag","updateDraggable","handlePointerDown","handlePointerUp","handlePointerDone","handleDragStart","handleDragMove","handleDragEnd","handleStaticClick","handles","viewport","bindHandles","unbindHandles","element","classList","remove","options","isDraggable","slides","length","toggle","isFreeScrolling","event","bindActivePointerEvents","isTouchStart","type","isTouchPointer","pointerType","isFocusNode","target","matches","preventDefault","focus","document","activeElement","blur","dragX","x","add","pointerDownScroll","getScrollPosition","addEventListener","hasDragStarted","moveVector","Math","abs","isTouchScrolling","removeEventListener","dragStartPosition","startAnimation","pointer","previousDragX","direction","rightToLeft","isWrapping","slideableWidth","originBound","max","endBound","min","getLastSlide","dragMoveTime","Date","freeScroll","index","dragEndRestingSelect","restingX","getRestingPosition","selectedIndex","dragEndBoostSelect","isDragSelect","select","distance","getSlideDistance","positiveResting","_getClosestResting","negativeResting","increment","minDistance","Infinity","condition","contain","dist","minDist","len","isWrapAround","wrapAround","slideIndex","modulo","slide","wrap","floor","undefined","delta","onscroll","scroll","scrollMoveX","scrollMoveY","y","pointerDone","pageXOffset","pageYOffset"],"sources":["E:/Intelliper/intelliper/node_modules/flickity/js/drag.js"],"sourcesContent":["// drag\n( function( window, factory ) {\n  // universal module definition\n  if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n        window,\n        require('./core'),\n        require('unidragger'),\n        require('fizzy-ui-utils'),\n    );\n  } else {\n    // browser global\n    window.Flickity = factory(\n        window,\n        window.Flickity,\n        window.Unidragger,\n        window.fizzyUIUtils,\n    );\n  }\n\n}( typeof window != 'undefined' ? window : this,\n    function factory( window, Flickity, Unidragger, utils ) {\n\n// ----- defaults ----- //\n\nObject.assign( Flickity.defaults, {\n  draggable: '>1',\n  dragThreshold: 3,\n} );\n\n// -------------------------- drag prototype -------------------------- //\n\nlet proto = Flickity.prototype;\nObject.assign( proto, Unidragger.prototype ); // inherit Unidragger\nproto.touchActionValue = '';\n\n// --------------------------  -------------------------- //\n\nFlickity.create.drag = function() {\n  this.on( 'activate', this.onActivateDrag );\n  this.on( 'uiChange', this._uiChangeDrag );\n  this.on( 'deactivate', this.onDeactivateDrag );\n  this.on( 'cellChange', this.updateDraggable );\n  this.on( 'pointerDown', this.handlePointerDown );\n  this.on( 'pointerUp', this.handlePointerUp );\n  this.on( 'pointerDown', this.handlePointerDone );\n  this.on( 'dragStart', this.handleDragStart );\n  this.on( 'dragMove', this.handleDragMove );\n  this.on( 'dragEnd', this.handleDragEnd );\n  this.on( 'staticClick', this.handleStaticClick );\n  // TODO updateDraggable on resize? if groupCells & slides change\n};\n\nproto.onActivateDrag = function() {\n  this.handles = [ this.viewport ];\n  this.bindHandles();\n  this.updateDraggable();\n};\n\nproto.onDeactivateDrag = function() {\n  this.unbindHandles();\n  this.element.classList.remove('is-draggable');\n};\n\nproto.updateDraggable = function() {\n  // disable dragging if less than 2 slides. #278\n  if ( this.options.draggable === '>1' ) {\n    this.isDraggable = this.slides.length > 1;\n  } else {\n    this.isDraggable = this.options.draggable;\n  }\n  this.element.classList.toggle( 'is-draggable', this.isDraggable );\n};\n\nproto._uiChangeDrag = function() {\n  delete this.isFreeScrolling;\n};\n\n// -------------------------- pointer events -------------------------- //\n\nproto.handlePointerDown = function( event ) {\n  if ( !this.isDraggable ) {\n    // proceed for staticClick\n    this.bindActivePointerEvents( event );\n    return;\n  }\n\n  let isTouchStart = event.type === 'touchstart';\n  let isTouchPointer = event.pointerType === 'touch';\n  let isFocusNode = event.target.matches('input, textarea, select');\n  if ( !isTouchStart && !isTouchPointer && !isFocusNode ) event.preventDefault();\n  if ( !isFocusNode ) this.focus();\n  // blur\n  if ( document.activeElement !== this.element ) document.activeElement.blur();\n  // stop if it was moving\n  this.dragX = this.x;\n  this.viewport.classList.add('is-pointer-down');\n  // track scrolling\n  this.pointerDownScroll = getScrollPosition();\n  window.addEventListener( 'scroll', this );\n  this.bindActivePointerEvents( event );\n};\n\n// ----- move ----- //\n\nproto.hasDragStarted = function( moveVector ) {\n  return Math.abs( moveVector.x ) > this.options.dragThreshold;\n};\n\n// ----- up ----- //\n\nproto.handlePointerUp = function() {\n  delete this.isTouchScrolling;\n  this.viewport.classList.remove('is-pointer-down');\n};\n\nproto.handlePointerDone = function() {\n  window.removeEventListener( 'scroll', this );\n  delete this.pointerDownScroll;\n};\n\n// -------------------------- dragging -------------------------- //\n\nproto.handleDragStart = function() {\n  if ( !this.isDraggable ) return;\n\n  this.dragStartPosition = this.x;\n  this.startAnimation();\n  window.removeEventListener( 'scroll', this );\n};\n\nproto.handleDragMove = function( event, pointer, moveVector ) {\n  if ( !this.isDraggable ) return;\n\n  event.preventDefault();\n\n  this.previousDragX = this.dragX;\n  // reverse if right-to-left\n  let direction = this.options.rightToLeft ? -1 : 1;\n  // wrap around move. #589\n  if ( this.isWrapping ) moveVector.x %= this.slideableWidth;\n  let dragX = this.dragStartPosition + moveVector.x * direction;\n\n  if ( !this.isWrapping ) {\n    // slow drag\n    let originBound = Math.max( -this.slides[0].target, this.dragStartPosition );\n    dragX = dragX > originBound ? ( dragX + originBound ) * 0.5 : dragX;\n    let endBound = Math.min( -this.getLastSlide().target, this.dragStartPosition );\n    dragX = dragX < endBound ? ( dragX + endBound ) * 0.5 : dragX;\n  }\n\n  this.dragX = dragX;\n  this.dragMoveTime = new Date();\n};\n\nproto.handleDragEnd = function() {\n  if ( !this.isDraggable ) return;\n\n  let { freeScroll } = this.options;\n  if ( freeScroll ) this.isFreeScrolling = true;\n  // set selectedIndex based on where flick will end up\n  let index = this.dragEndRestingSelect();\n\n  if ( freeScroll && !this.isWrapping ) {\n    // if free-scroll & not wrap around\n    // do not free-scroll if going outside of bounding slides\n    // so bounding slides can attract slider, and keep it in bounds\n    let restingX = this.getRestingPosition();\n    this.isFreeScrolling = -restingX > this.slides[0].target &&\n      -restingX < this.getLastSlide().target;\n  } else if ( !freeScroll && index === this.selectedIndex ) {\n    // boost selection if selected index has not changed\n    index += this.dragEndBoostSelect();\n  }\n  delete this.previousDragX;\n  // apply selection\n  // HACK, set flag so dragging stays in correct direction\n  this.isDragSelect = this.isWrapping;\n  this.select( index );\n  delete this.isDragSelect;\n};\n\nproto.dragEndRestingSelect = function() {\n  let restingX = this.getRestingPosition();\n  // how far away from selected slide\n  let distance = Math.abs( this.getSlideDistance( -restingX, this.selectedIndex ) );\n  // get closet resting going up and going down\n  let positiveResting = this._getClosestResting( restingX, distance, 1 );\n  let negativeResting = this._getClosestResting( restingX, distance, -1 );\n  // use closer resting for wrap-around\n  return positiveResting.distance < negativeResting.distance ?\n    positiveResting.index : negativeResting.index;\n};\n\n/**\n * given resting X and distance to selected cell\n * get the distance and index of the closest cell\n * @param {Number} restingX - estimated post-flick resting position\n * @param {Number} distance - distance to selected cell\n * @param {Integer} increment - +1 or -1, going up or down\n * @returns {Object} - { distance: {Number}, index: {Integer} }\n */\nproto._getClosestResting = function( restingX, distance, increment ) {\n  let index = this.selectedIndex;\n  let minDistance = Infinity;\n  let condition = this.options.contain && !this.isWrapping ?\n    // if containing, keep going if distance is equal to minDistance\n    ( dist, minDist ) => dist <= minDist :\n    ( dist, minDist ) => dist < minDist;\n\n  while ( condition( distance, minDistance ) ) {\n    // measure distance to next cell\n    index += increment;\n    minDistance = distance;\n    distance = this.getSlideDistance( -restingX, index );\n    if ( distance === null ) break;\n\n    distance = Math.abs( distance );\n  }\n  return {\n    distance: minDistance,\n    // selected was previous index\n    index: index - increment,\n  };\n};\n\n/**\n * measure distance between x and a slide target\n * @param {Number} x - horizontal position\n * @param {Integer} index - slide index\n * @returns {Number} - slide distance\n */\nproto.getSlideDistance = function( x, index ) {\n  let len = this.slides.length;\n  // wrap around if at least 2 slides\n  let isWrapAround = this.options.wrapAround && len > 1;\n  let slideIndex = isWrapAround ? utils.modulo( index, len ) : index;\n  let slide = this.slides[ slideIndex ];\n  if ( !slide ) return null;\n\n  // add distance for wrap-around slides\n  let wrap = isWrapAround ? this.slideableWidth * Math.floor( index/len ) : 0;\n  return x - ( slide.target + wrap );\n};\n\nproto.dragEndBoostSelect = function() {\n  // do not boost if no previousDragX or dragMoveTime\n  if ( this.previousDragX === undefined || !this.dragMoveTime ||\n    // or if drag was held for 100 ms\n    new Date() - this.dragMoveTime > 100 ) {\n    return 0;\n  }\n\n  let distance = this.getSlideDistance( -this.dragX, this.selectedIndex );\n  let delta = this.previousDragX - this.dragX;\n  if ( distance > 0 && delta > 0 ) {\n    // boost to next if moving towards the right, and positive velocity\n    return 1;\n  } else if ( distance < 0 && delta < 0 ) {\n    // boost to previous if moving towards the left, and negative velocity\n    return -1;\n  }\n  return 0;\n};\n\n// ----- scroll ----- //\n\nproto.onscroll = function() {\n  let scroll = getScrollPosition();\n  let scrollMoveX = this.pointerDownScroll.x - scroll.x;\n  let scrollMoveY = this.pointerDownScroll.y - scroll.y;\n  // cancel click/tap if scroll is too much\n  if ( Math.abs( scrollMoveX ) > 3 || Math.abs( scrollMoveY ) > 3 ) {\n    this.pointerDone();\n  }\n};\n\n// ----- utils ----- //\n\nfunction getScrollPosition() {\n  return {\n    x: window.pageXOffset,\n    y: window.pageYOffset,\n  };\n}\n\n// -----  ----- //\n\nreturn Flickity;\n\n} ) );\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}