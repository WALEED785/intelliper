// src/use-snap-carousel.tsx
import { useState, useCallback, useLayoutEffect, useEffect } from "react";
var useSnapCarousel = ({
  axis = "x",
  snapPointClassName
} = {}) => {
  const dimension = axis === "x" ? "width" : "height";
  const scrollDimension = axis === "x" ? "scrollWidth" : "scrollHeight";
  const clientDimension = axis === "x" ? "clientWidth" : "clientHeight";
  const nearSidePos = axis === "x" ? "left" : "top";
  const farSidePos = axis === "x" ? "right" : "bottom";
  const scrollPos = axis === "x" ? "scrollLeft" : "scrollTop";
  const offsetPos = axis === "x" ? "offsetLeft" : "offsetTop";
  const [scrollEl, setScrollEl] = useState(null);
  const [{ pages, activePageIndex }, setCarouselState] = useState({
    pages: [],
    activePageIndex: 0
  });
  const refreshActivePage = useCallback(
    (pages2) => {
      if (!scrollEl) {
        return;
      }
      const hasScrolledToEnd = Math.floor(scrollEl[scrollDimension] - scrollEl[scrollPos]) <= scrollEl[clientDimension];
      if (hasScrolledToEnd) {
        setCarouselState({ pages: pages2, activePageIndex: pages2.length - 1 });
        return;
      }
      const items = Array.from(scrollEl.children);
      const scrollPort = scrollEl.getBoundingClientRect();
      const offsets = pages2.map((page) => {
        const leadIndex = page[0];
        const leadEl = items[leadIndex];
        const rect = leadEl.getBoundingClientRect();
        const offset = rect[nearSidePos] - scrollPort[nearSidePos];
        return Math.abs(offset);
      });
      const minOffset = Math.min(...offsets);
      const nextActivePageIndex = offsets.indexOf(minOffset);
      setCarouselState({ pages: pages2, activePageIndex: nextActivePageIndex });
    },
    [scrollEl, clientDimension, nearSidePos, scrollDimension, scrollPos]
  );
  const refresh = useCallback(() => {
    if (!scrollEl) {
      return;
    }
    const items = Array.from(scrollEl.children);
    const scrollPort = scrollEl.getBoundingClientRect();
    let currPageDimension = 0;
    let allItemsDimension = 0;
    const pages2 = items.reduce((acc, item, i) => {
      const currPage = acc[acc.length - 1];
      const itemDimension = item.getBoundingClientRect()[farSidePos] - scrollPort[nearSidePos] + scrollEl[scrollPos] - allItemsDimension;
      currPageDimension += itemDimension;
      allItemsDimension += itemDimension;
      if (!currPage || currPageDimension > scrollPort[dimension]) {
        acc.push([i]);
        currPageDimension = itemDimension;
      } else {
        currPage.push(i);
      }
      return acc;
    }, []);
    refreshActivePage(pages2);
  }, [
    refreshActivePage,
    scrollEl,
    dimension,
    farSidePos,
    nearSidePos,
    scrollPos
  ]);
  useLayoutEffect(() => {
    refresh();
  }, [refresh]);
  useEffect(() => {
    const handle = () => {
      refresh();
    };
    window.addEventListener("resize", handle);
    window.addEventListener("orientationchange", handle);
    return () => {
      window.removeEventListener("resize", handle);
      window.removeEventListener("orientationchange", handle);
    };
  }, [refresh]);
  useEffect(() => {
    if (!scrollEl) {
      return;
    }
    const handle = () => {
      refreshActivePage(pages);
    };
    scrollEl.addEventListener("scroll", handle);
    return () => {
      scrollEl.removeEventListener("scroll", handle);
    };
  }, [refreshActivePage, pages, scrollEl]);
  const handleGoTo = (index) => {
    if (!scrollEl) {
      return;
    }
    const page = pages[index];
    if (!page) {
      return;
    }
    const items = Array.from(scrollEl.children);
    const leadIndex = page[0];
    const leadEl = items[leadIndex];
    if (!(leadEl instanceof HTMLElement)) {
      return;
    }
    scrollEl.scrollTo({
      behavior: "smooth",
      [nearSidePos]: leadEl[offsetPos]
    });
  };
  const handlePrev = () => {
    handleGoTo(activePageIndex - 1);
  };
  const handleNext = () => {
    handleGoTo(activePageIndex + 1);
  };
  useLayoutEffect(() => {
    if (!scrollEl) {
      return;
    }
    const setSnapPoint = (el) => snapPointClassName ? el.classList.add(snapPointClassName) : el.style.scrollSnapAlign = "start";
    const clearSnapPoint = (el) => snapPointClassName ? el.classList.remove(snapPointClassName) : el.style.scrollSnapAlign = "";
    const items = Array.from(scrollEl.children);
    const snapPointIndexes = new Set(pages.map((page) => page[0]));
    items.forEach((item, i) => {
      if (!(item instanceof HTMLElement)) {
        return;
      }
      if (snapPointIndexes.has(i)) {
        setSnapPoint(item);
      } else {
        clearSnapPoint(item);
      }
    });
    return () => {
      items.forEach((item) => {
        if (!(item instanceof HTMLElement)) {
          return;
        }
        clearSnapPoint(item);
      });
    };
  }, [pages, scrollEl, snapPointClassName]);
  return {
    prev: handlePrev,
    next: handleNext,
    goTo: handleGoTo,
    refresh,
    pages,
    activePageIndex,
    scrollRef: setScrollEl
  };
};
export {
  useSnapCarousel
};
