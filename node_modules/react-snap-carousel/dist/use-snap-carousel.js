"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/use-snap-carousel.tsx
var use_snap_carousel_exports = {};
__export(use_snap_carousel_exports, {
  useSnapCarousel: () => useSnapCarousel
});
module.exports = __toCommonJS(use_snap_carousel_exports);
var import_react = require("react");
var useSnapCarousel = ({
  axis = "x",
  snapPointClassName
} = {}) => {
  const dimension = axis === "x" ? "width" : "height";
  const scrollDimension = axis === "x" ? "scrollWidth" : "scrollHeight";
  const clientDimension = axis === "x" ? "clientWidth" : "clientHeight";
  const nearSidePos = axis === "x" ? "left" : "top";
  const farSidePos = axis === "x" ? "right" : "bottom";
  const scrollPos = axis === "x" ? "scrollLeft" : "scrollTop";
  const offsetPos = axis === "x" ? "offsetLeft" : "offsetTop";
  const [scrollEl, setScrollEl] = (0, import_react.useState)(null);
  const [{ pages, activePageIndex }, setCarouselState] = (0, import_react.useState)({
    pages: [],
    activePageIndex: 0
  });
  const refreshActivePage = (0, import_react.useCallback)(
    (pages2) => {
      if (!scrollEl) {
        return;
      }
      const hasScrolledToEnd = Math.floor(scrollEl[scrollDimension] - scrollEl[scrollPos]) <= scrollEl[clientDimension];
      if (hasScrolledToEnd) {
        setCarouselState({ pages: pages2, activePageIndex: pages2.length - 1 });
        return;
      }
      const items = Array.from(scrollEl.children);
      const scrollPort = scrollEl.getBoundingClientRect();
      const offsets = pages2.map((page) => {
        const leadIndex = page[0];
        const leadEl = items[leadIndex];
        const rect = leadEl.getBoundingClientRect();
        const offset = rect[nearSidePos] - scrollPort[nearSidePos];
        return Math.abs(offset);
      });
      const minOffset = Math.min(...offsets);
      const nextActivePageIndex = offsets.indexOf(minOffset);
      setCarouselState({ pages: pages2, activePageIndex: nextActivePageIndex });
    },
    [scrollEl, clientDimension, nearSidePos, scrollDimension, scrollPos]
  );
  const refresh = (0, import_react.useCallback)(() => {
    if (!scrollEl) {
      return;
    }
    const items = Array.from(scrollEl.children);
    const scrollPort = scrollEl.getBoundingClientRect();
    let currPageDimension = 0;
    let allItemsDimension = 0;
    const pages2 = items.reduce((acc, item, i) => {
      const currPage = acc[acc.length - 1];
      const itemDimension = item.getBoundingClientRect()[farSidePos] - scrollPort[nearSidePos] + scrollEl[scrollPos] - allItemsDimension;
      currPageDimension += itemDimension;
      allItemsDimension += itemDimension;
      if (!currPage || currPageDimension > scrollPort[dimension]) {
        acc.push([i]);
        currPageDimension = itemDimension;
      } else {
        currPage.push(i);
      }
      return acc;
    }, []);
    refreshActivePage(pages2);
  }, [
    refreshActivePage,
    scrollEl,
    dimension,
    farSidePos,
    nearSidePos,
    scrollPos
  ]);
  (0, import_react.useLayoutEffect)(() => {
    refresh();
  }, [refresh]);
  (0, import_react.useEffect)(() => {
    const handle = () => {
      refresh();
    };
    window.addEventListener("resize", handle);
    window.addEventListener("orientationchange", handle);
    return () => {
      window.removeEventListener("resize", handle);
      window.removeEventListener("orientationchange", handle);
    };
  }, [refresh]);
  (0, import_react.useEffect)(() => {
    if (!scrollEl) {
      return;
    }
    const handle = () => {
      refreshActivePage(pages);
    };
    scrollEl.addEventListener("scroll", handle);
    return () => {
      scrollEl.removeEventListener("scroll", handle);
    };
  }, [refreshActivePage, pages, scrollEl]);
  const handleGoTo = (index) => {
    if (!scrollEl) {
      return;
    }
    const page = pages[index];
    if (!page) {
      return;
    }
    const items = Array.from(scrollEl.children);
    const leadIndex = page[0];
    const leadEl = items[leadIndex];
    if (!(leadEl instanceof HTMLElement)) {
      return;
    }
    scrollEl.scrollTo({
      behavior: "smooth",
      [nearSidePos]: leadEl[offsetPos]
    });
  };
  const handlePrev = () => {
    handleGoTo(activePageIndex - 1);
  };
  const handleNext = () => {
    handleGoTo(activePageIndex + 1);
  };
  (0, import_react.useLayoutEffect)(() => {
    if (!scrollEl) {
      return;
    }
    const setSnapPoint = (el) => snapPointClassName ? el.classList.add(snapPointClassName) : el.style.scrollSnapAlign = "start";
    const clearSnapPoint = (el) => snapPointClassName ? el.classList.remove(snapPointClassName) : el.style.scrollSnapAlign = "";
    const items = Array.from(scrollEl.children);
    const snapPointIndexes = new Set(pages.map((page) => page[0]));
    items.forEach((item, i) => {
      if (!(item instanceof HTMLElement)) {
        return;
      }
      if (snapPointIndexes.has(i)) {
        setSnapPoint(item);
      } else {
        clearSnapPoint(item);
      }
    });
    return () => {
      items.forEach((item) => {
        if (!(item instanceof HTMLElement)) {
          return;
        }
        clearSnapPoint(item);
      });
    };
  }, [pages, scrollEl, snapPointClassName]);
  return {
    prev: handlePrev,
    next: handleNext,
    goTo: handleGoTo,
    refresh,
    pages,
    activePageIndex,
    scrollRef: setScrollEl
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useSnapCarousel
});
